{"pages":[],"posts":[{"title":"PowerMock使用","text":"简介​ 可用于本地单元测试的框架。可模拟公有，私有方法返回数据；也可模拟静态属性数据，实例属性数据；模拟Spring Bean 实例及注入等。 与Mockito的区别PowerMock较Mockito强大一点，可以模拟私有方法，静态方法，final 类。 maven依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-api-mockito2&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 说明@Mock 和 @Spy 区别@Mock：模拟出来的对象，其所有方法是空的，调用都返回空，真实的方法不会执行。 @Spy：模拟出来的对象，其所有方法都是真实的，调用都按真实方法去调用，因此很可能依赖真实的环境。除非mock 对应的方法，才会覆盖。 doReturn()…when() 和when()…thenReturn() 的区别mock 出来的对象： 没有区别。 spy出来的对象：doReturn()…when() 和when()…thenReturn() 是有区别的 使用模拟公有方法 设置Runner环境为PowerMockRunner 123456// FoodMenuServiceTest.class ...@RunWith(PowerMockRunner.class)public class FoodMenuServiceTest{ // ...} 定义Mock属性和需要注入的属性。 1234567891011// FoodMenuServiceTest.class ...// 需要注入（Mock的属性）的属性,此处需要new具体类 @InjectMocks private FoodMenuService foodMenuService = new FoodMenuServiceImpl();// Mock 的属性 @Mock private MaterialService materialService;// ... 构造数据，模拟方法，运行 12345678910111213141516171819202122 // FoodMenuServiceTest.class ...@Test public void mockPublicMethod() { // 数据 Material fish = Material.builder().name(\"鱼\").build(); Material crayFish = Material.builder().name(\"小龙虾\").build(); ArrayList&lt;Material&gt; materials = CollUtil.newArrayList(fish, crayFish); // 模拟方法 list PowerMockito.when(materialService.list()).thenReturn(materials); // 调用 List&lt;Food&gt; list = foodMenuService.list(); // 打印结果 // [Food(name=红烧鱼), Food(name=水煮鱼), Food(name=麻辣小龙虾), Food(name=清蒸小龙虾)] System.out.println(list); }// ... 模拟私有方法 设置runner环境为PowerMockRunner,并设置PrepareForTest为需要测试的类PrepareForTest 123456// MockPrivateMethodTest.class@RunWith(PowerMockRunner.class)@PrepareForTest(MaterialServiceImpl.class)public class MockPrivateMethodTest { // ...} 定义需要Spy的属性 123// MockPrivateMethodTest.class @Spy private MaterialService materialService = new MaterialServiceImpl(); 构造数据，模拟方法，运行 123456789101112131415161718192021// MockPrivateMethodTest.class@Test public void mockPrivateMethod() throws Exception { // 数据 Material fish = Material.builder().name(\"鱼\").build(); Material crayFish = Material.builder().name(\"小龙虾\").build(); ArrayList&lt;Material&gt; materials = CollUtil.newArrayList(fish, crayFish); // 模拟方法 // 区别于 PowerMockito.when(materialService, \"pri\").thenReturn(materials); PowerMockito.doReturn(materials).when(materialService, \"pri\"); // 执行 List&lt;Material&gt; list = materialService.listForPri(); // 打印 // [Material(name=鱼), Material(name=小龙虾)] System.out.println(list); } 同时模拟共有和私有方法，并注入 设置Runner和PrepareForTest 123456// MockPublicAndPrivateMethodTest.class@RunWith(PowerMockRunner.class)@PrepareForTest(MaterialServiceImpl.class)public class MockPublicAndPrivateMethodTest { // ...} 定义属性 123456 @InjectMocks private FoodMenuService foodMenuService = new FoodMenuServiceImpl();// 因为要调用 MaterialService.listForPubAndPri的实际方法，顾使用 @Spy，如不需可使用@Mock @Spy private MaterialService materialService = new MaterialServiceImpl(); 构造数据，模拟方法，运行 123456789101112131415161718192021222324@Test public void mockPublicAndPrivateMethod() throws Exception { // 构造数据 Material fish = Material.builder().name(\"鱼\").build(); Material crayFish = Material.builder().name(\"小龙虾\").build(); ArrayList&lt;Material&gt; materialsA = CollUtil.newArrayList(fish); ArrayList&lt;Material&gt; materialsB = CollUtil.newArrayList(crayFish); // 模拟公有方法 // 此处用方法名的形式是因为 spy出来的对象具有真实方法，以方法名的方式调用不会执行真实方法。 PowerMockito.doReturn(materialsA).when(materialService, \"list\"); // 模拟私有方法 PowerMockito.doReturn(materialsB).when(materialService, \"pri\"); // 运行 List&lt;Food&gt; list = foodMenuService.listForPubAndPri(); // 打印 // [Food(name=红烧鱼), Food(name=水煮鱼), Food(name=麻辣小龙虾), Food(name=清蒸小龙虾)] System.out.println(list); } 模拟静态方法1234567891011121314151617181920212223242526272829import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.powermock.api.mockito.PowerMockito;import org.powermock.core.classloader.annotations.PrepareForTest;import org.powermock.modules.junit4.PowerMockRunner;@RunWith(PowerMockRunner.class)@PrepareForTest(StaticMethodAndField.class)public class StaticMethodAndFieldTest { // 期望数据 public static final String expect = \"127.0.0.1\"; @Test public void mockStaticMethod() { // 模拟方法 PowerMockito.mockStatic(StaticMethodAndField.class); PowerMockito.when(StaticMethodAndField.getIp()).thenReturn(expect); // 调用 String ip = StaticMethodAndField.getIp(); // 断言 Assert.assertEquals(expect, ip); }} 模拟静态私有属性12345678910111213141516171819202122232425262728293031323334353637383940@RunWith(PowerMockRunner.class)@PrepareForTest(StaticMethodAndField.class)public class StaticMethodAndFieldTest { // 期望数据 public static final String expect = \"127.0.0.1\"; /** * 参考 https://qa.1r1g.com/sf/ask/1621376431/ * @throws NoSuchFieldException * @throws IllegalAccessException */ @Test public void mockFinalField() throws NoSuchFieldException, IllegalAccessException { // 模拟属性 // 获取字段 Field field = Whitebox.getField(StaticMethodAndField.class, \"IP\"); // 设置成public field.setAccessible(true); // 获取 修饰器 Field modifiersField = Field.class.getDeclaredField(\"modifiers\"); // 设置为可使用的 modifiersField.setAccessible(true); // 消除 FINAL 修饰器 modifiersField.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL); // 设置新值 field.set(null, expect); // 断言 Assert.assertEquals(expect, StaticMethodAndField.IP); }} 模拟枚举类1234567891011121314151617181920212223242526272829303132import org.junit.Test;import org.junit.runner.RunWith;import org.powermock.api.mockito.PowerMockito;import org.powermock.core.classloader.annotations.PrepareForTest;import org.powermock.modules.junit4.PowerMockRunner;import org.powermock.reflect.Whitebox;import static org.junit.Assert.*;@RunWith(PowerMockRunner.class)@PrepareForTest(Colors.class)public class ColorsTest { @Test public void mockEnums() { // 期望的数据 String expect = \"模拟的蓝色\"; // 模拟的实例 Colors instance = PowerMockito.mock(Colors.class); // 替换实例 Whitebox.setInternalState(Colors.class, \"BLUE\", instance); // 模拟方法 PowerMockito.when(instance.getName() ).thenReturn(expect); // 断言 assertEquals(expect, Colors.BLUE.getName()); }} 项目源码1https://github.com/iaoongin/summary-project/sp-powermock","link":"/2020/10/20/PowerMock使用/"},{"title":"IDEA打印彩色日志","text":"完成以下步骤即可,非必须完成所有步骤修改logback.xml123456789&lt;!-- logback.xml --&gt;&lt;!-- 彩色日志 --&gt;&lt;!-- 彩色日志依赖的渲染类 --&gt;&lt;conversionRule conversionWord=\"clr\" converterClass=\"org.springframework.boot.logging.logback.ColorConverter\" /&gt;&lt;conversionRule conversionWord=\"wex\" converterClass=\"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter\" /&gt;&lt;conversionRule conversionWord=\"wEx\" converterClass=\"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter\" /&gt;&lt;!-- 彩色日志格式 --&gt;&lt;property name=\"FILE_LOG_PATTERN\" value=\"${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}\" /&gt; 打开设置 File–Settings–Maven–Runner在 VM option 添加 1-Dspring.output.ansi.enabled=ALWAYS 打开设置 Edit-Cofiguration在 VM option 添加 1-Dspring.output.ansi.enabled=ALWAYS 效果图","link":"/2019/08/20/IDEA打印彩色日志/"},{"title":"Welcome","text":"","link":"/2019/08/14/Welcome/"},{"title":"SVN错误：XXX is scheduled for addition, but is missing","text":"解决方式告诉SVN把这个文件退回到之前的状态 “unversioned”，也就是不对这个文件做任何修改，执行完提交即可。 xxx 必须是全路径 1svn revert xxx --depth infinity 如 1svn revert H:\\abc\\config\\feign --depth infinity 场景发生在 copy to branch or tag时 原因使用svn标记了将要提交的文件，此时被你删除了，再进行提交的时候，就会找不到。 拓展svn revert 顾名思义是对修改过的东西进行回滚。如对已修改未提交的文件回滚； 深度（depth） 1234--depth empty：只包含目录自身，不包含目录下的任何文件和子目录。--depth files： 包含目录和目录下的文件，不包含子目录。--depth immediates： 包含目录和目录下的文件及子目录。但不对子目录递归。--depth infinity： 这是默认的，包含整个目录树。 svn status 查看文件状态。 本文参考SVN错误：but is missing","link":"/2019/08/19/SVN错误：XXX-is-scheduled-for-addition-but-is-missing/"},{"title":"logstash input-jdbc 分页性能优化问题","text":"原因logstash 自带分页查询,竟然是查处所有数据再计数的。 1SELECT count(*) AS `count` FROM (SELECT * FROM ip_bundle_data_20190813) AS `t1` LIMIT 1 解决办法：修改源码文件位置1logstash-7.2.0\\vendor\\bundle\\jruby\\2.5.0\\gems\\logstash-input-jdbc-4.3.13\\lib\\logstash\\plugin_mixins\\jdbc\\jdbc.rb 添加参数123456// line:100 =&gt; config# 开启子查询分页 @boole 2018-03-30config :subquery_paging_enabled, :validate =&gt; :boolean, :default =&gt; false# 总数sql，结果集列名为sum。for example `select count(*) as sum from goods` @boole 2018-03-30config :sum_statement, :validate =&gt; :string 修改方法123456789101112131415161718192021222324252627282930// line:254 =&gt; perform_queryprivate def perform_query(query) #subquery paging @boole 2018-03-30 if @subquery_paging_enabled @logger.info(&quot;################### subquery paging optimization ################&quot;) data_sum = @database[@sum_statement].get(:sum) @logger.info(&quot;data_sum=#{data_sum}&quot;) data_offset = 0 while data_offset &lt; data_sum do @logger.info(&quot;data_offset=#{data_offset}&quot;) sub_page_query = @database[@statement, symbolized_params({&quot;data_offset&quot; =&gt; data_offset, &quot;jdbc_page_size&quot; =&gt; @jdbc_page_size})] sub_page_query.each do |row| yield row end data_offset += @jdbc_page_size end elsif @jdbc_paging_enabled query.each_page(@jdbc_page_size) do |paged_dataset| paged_dataset.each do |row| yield row end end else query.each do |row| yield row end end end 配置logstash.confsql中使用:data_offset和:jdbc_page_size进行分页 12345statement =&gt; &quot;SELECT * FROM ip_bundle_data_20190813 limit :data_offset,:jdbc_page_size&quot;subquery_paging_enabled =&gt; &quot;true&quot;sum_statement =&gt; &quot;select count(*) as `count` from ip_bundle_data_20190813&quot;","link":"/2019/08/14/logstash-分页优化/"},{"title":"mysql导入大文件失败解决方法","text":"解决方式修改/etc/my.conf,在以指定区域新增以下行 1234567891011[mysqld]#### 避免导入失败max_allowed_packet = 200M[mysqlhotcopy]interactive-timeout=28800000wait_timeout=28800000#### 避免导入失败 场景导入的sql文件较大时，或者网络状况不好。 原因mysql 默认配置超时时间及支持文件大小限制太小","link":"/2019/08/20/mysql导入大文件失败解决方法/"},{"title":"git push 本地项目到远程仓库","text":"1.进入项目目录1cd H:\\blog 2.初始化仓库1git init 3.添加所有文件到仓库1git add -A 4.提交1git commit -m &quot;init&quot; 5.建立好远程仓库1https://github.com/iaoongin/iaoongin.github.io.git 6.配置远程仓库http方式此方式需要输入密码12git remote add origin https://github.com/iaoongin/iaoongin.github.io.git// origin 是远程仓库的别名，用于代替git仓库地址 ssh方式此方式需要生成秘钥1git remote add origin git@github.com:iaoongin/iaoongin.github.io.git 1ssh-keygen -t rsa -C &quot;这里换上你的邮箱&quot; 生成秘钥,如下图 配置远程仓库key 7.开始推送12git push origin master:source// git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 分支说明12345// 本地默认初始为master分支// git branch -a 查看所有本地分支// git branch 查看当前分支// git branch abc 创建分支abc// git checkout abc 切换abc分支","link":"/2019/08/16/git-push-本地项目到远程仓库/"},{"title":"Spring Cloud Gateway 的使用","text":"框架说明用于统一服务的出入口。 注意由于该项目使用的是Spring WebFlux，区别与Spring WebMvc。 带来的优势 做统一权限（目前） 统一日志 … 词汇路由 Route：一个组合，包含下面两个部分。 断言 Predicate：相当于转发条件。 过滤器 Filter：相当于转发规则。 有关类org.springframework.cloud.gateway.route.RouteDefinition 属性 类型 说明 id String 路由id，唯一标识。 predicates List 断言集合。 filters List 过滤集合。 uri URI 目标地址。支持http和lb。 metadata Map&lt;String, Object&gt; 元数据。 order int 顺序。 org.springframework.cloud.gateway.handler.predicate.PredicateDefinition 属性 类型 说明 name String RoutePredicateFactory名称。如：Path args Map&lt;String, String&gt; 参数。不同的RoutePredicateFactory，有不一样的参数。 org.springframework.cloud.gateway.filter.FilterDefinition 属性 类型 说明 name String GatewayFilterFactory名称。如：RewritePath，StripPrefix。 args Map&lt;String, String&gt; 参数。不同的GatewayFilterFactory，有不一样的参数。 使用动态路由说明​ 通过实现 org.springframework.cloud.gateway.route.RouteDefinitionRepository 接口，实现路由获取方式。 ​ 来自org.springframework.cloud.gateway.route.CachingRouteDefinitionLocator#fetch 的调用。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.ystmob.mg.api.config.gatewayroute;import cn.hutool.json.JSONUtil;import com.ystmob.mg.api.service.GatewayRouteService;import lombok.extern.slf4j.Slf4j;import org.springframework.cloud.gateway.route.RouteDefinition;import org.springframework.cloud.gateway.route.RouteDefinitionRepository;import org.springframework.stereotype.Component;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;import javax.annotation.Resource;import java.util.stream.Collectors;@Slf4j@Componentpublic class DynamicRouteDefinitionRepository implements RouteDefinitionRepository { @Resource private GatewayRouteService gatewayRouteService; @Override public Flux&lt;RouteDefinition&gt; getRouteDefinitions() { return gatewayRouteService.listStatusOn() .flatMapIterable(gatewayRoutes -&gt; gatewayRoutes.stream().map(gr -&gt; { String jsonString = JSONUtil.toJsonStr(gr); RouteDefinition routeDefinition = JSONUtil.toBean(jsonString, RouteDefinition.class); // id 对 routeId routeDefinition.setId(gr.getRouteId()); return routeDefinition; }).collect(Collectors.toList())); } @Override public Mono&lt;Void&gt; save(Mono&lt;RouteDefinition&gt; route) { return Mono.empty(); } @Override public Mono&lt;Void&gt; delete(Mono&lt;String&gt; routeId) { return Mono.empty(); }} 路由刷新通过发布事件，通知监听器刷新。 123456@ResourceApplicationEventPublisher publisher;... publisher.publishEvent(new RefreshRoutesEvent(this));... 监听器 org.springframework.cloud.gateway.route.CachingRouteDefinitionLocator#onApplicationEvent org.springframework.cloud.gateway.route.CachingRouteLocator#onApplicationEvent 静态路由通过配置yml文件，即提前声明的形式。 比如 123456789101112131415161718spring: application: name: stock-gateway cloud: gateway: routes: - id: stock-finance uri: lb://stock-finance predicates: - Path=/stock-finance/** filters: - RewritePath=/stock-finance, / - id: stock-ii uri: http://localhost:8510 predicates: - Path=/stock-ii/** filters: - RewritePath=/stock-ii, /","link":"/2020/06/09/Spring Cloud Gateway 的使用/"},{"title":"spring中将配置文件的属性注入到静态属性里","text":"场景如在工具类中，不想将该工具类被spring管理，通过引用其他类的的静态属性获取值。 步骤application.properties123456#局域网地址file.lanServer=\\\\\\\\DESKTOP-3FE3ORR\\\\app\\\\#app下载地址file.remoteServer=http://127.0.0.1:8080/app/file.fileUploadDir=H:/vadxfile.relatePath=/vadx/app 新建类, 如文件路径配置123456789101112131415161718192021222324252627282930@Component@Getter@Setterpublic class FileProp { public static String remoteServer; public static String lanServer; public static String fileUploadDir; public static String relatePath; @Value(\"${file.remoteServer}\") public void setRemoteServer(String remoteServer) { FileProp.remoteServer = remoteServer; } @Value(\"${file.lanServer}\") public void setLanServer(String lanServer) { FileProp.lanServer = lanServer; } @Value(\"${file.fileUploadDir}\") public void setFileUploadDir(String fileUploadDir) { FileProp.fileUploadDir = fileUploadDir; } @Value(\"${file.relatePath}\") public void setRelatePath(String relatePath) { FileProp.relatePath = relatePath; }} 使用，在工具类中使用123456@Slf4jpublic class UploadFileUtil { //项目前缀路径 public static String destFile = FileProp.fileUploadDir;}","link":"/2019/11/02/spring中将配置文件的属性注入到静态属性里/"},{"title":"windows-运行关闭jar包cmd脚本","text":"项目结构123456|--web |-- appname.txt // 存放jar包名字 |-- xxx.jar // jar包 |-- run.bat // 前台启动脚本 |-- run-demo.bat // 后台启动脚本 |-- stop.bat // 停止脚本 前台启动脚本12345chcp 65001for /f \"tokens=1\" %%j in ('findstr .* appname.txt') do ( title %%j java -jar -Dfile.encoding=UTF-8 -Dlogging.config=config/logback.xml -Dspring.profiles.active=pro -Dmybatis-plus.mapper-locations=file:config/mapper/*.xml \"%%j\" -Xms50m -Xmx1024m) 后台启动脚本12345chcp 65001for /f \"tokens=1\" %%j in ('findstr .* appname.txt') do ( title %%j start javaw -jar -Dlogging.config=config/logback.xml -Dspring.profiles.active=pro -Dmybatis-plus.mapper-locations=file:config/mapper/*.xml \"%%j\" -Xms256m -Xmx1g -Xss256k) 停止脚本注：&quot;C:\\Program Files\\Java\\jdk1.8.0_131\\bin\\jps&quot; 为jdk工具包 12345678910111213@echo off:: 找到jar的pid进程，并杀死for /f \"tokens=1\" %%j in ('findstr .* appname.txt') do ( for /f \"tokens=1\" %%i in ('\"C:\\Program Files\\Java\\jdk1.8.0_131\\bin\\jps\" -l ^| findstr %%j') do ( set n=%%i ))taskkill /f /pid %n%set n=exit 参考win bat脚本 后台运行jar包 获取当前用户所有java进程及jps命令的实现","link":"/2019/08/26/windows-运行关闭jar包cmd脚本/"},{"title":"logstash input-jdbc 分页性能优化问题","text":"原因logstash 自带分页查询,竟然是查处所有数据再计数的。 1SELECT count(*) AS `count` FROM (SELECT * FROM ip_bundle_data_20190813) AS `t1` LIMIT 1 解决办法：修改源码 文件位置 1logstash-7.2.0\\vendor\\bundle\\jruby\\2.5.0\\gems\\logstash-input-jdbc-4.3.13\\lib\\logstash\\plugin_mixins\\jdbc\\jdbc.rb 添加参数 123456// line:100 =&gt; config# 开启子查询分页 @boole 2018-03-30config :subquery_paging_enabled, :validate =&gt; :boolean, :default =&gt; false# 总数sql，结果集列名为sum。for example `select count(*) as sum from goods` @boole 2018-03-30config :sum_statement, :validate =&gt; :string 修改方法 123456789101112131415161718192021222324252627282930// line:254 =&gt; perform_queryprivate def perform_query(query) #subquery paging @boole 2018-03-30 if @subquery_paging_enabled @logger.info(&quot;################### subquery paging optimization ################&quot;) data_sum = @database[@sum_statement].get(:sum) @logger.info(&quot;data_sum=#{data_sum}&quot;) data_offset = 0 while data_offset &lt; data_sum do @logger.info(&quot;data_offset=#{data_offset}&quot;) sub_page_query = @database[@statement, symbolized_params({&quot;data_offset&quot; =&gt; data_offset, &quot;jdbc_page_size&quot; =&gt; @jdbc_page_size})] sub_page_query.each do |row| yield row end data_offset += @jdbc_page_size end elsif @jdbc_paging_enabled query.each_page(@jdbc_page_size) do |paged_dataset| paged_dataset.each do |row| yield row end end else query.each do |row| yield row end end end 配置logstash.conf sql中使用:data_offset和:jdbc_page_size进行分页 12345statement =&gt; &quot;SELECT * FROM ip_bundle_data_20190813 limit :data_offset,:jdbc_page_size&quot;subquery_paging_enabled =&gt; &quot;true&quot;sum_statement =&gt; &quot;select count(*) as `count` from ip_bundle_data_20190813&quot;","link":"/2019/08/14/logstash 分页优化/"}],"tags":[{"name":"mock","slug":"mock","link":"/tags/mock/"},{"name":"idea","slug":"idea","link":"/tags/idea/"},{"name":"log","slug":"log","link":"/tags/log/"},{"name":"svn","slug":"svn","link":"/tags/svn/"},{"name":"elk","slug":"elk","link":"/tags/elk/"},{"name":"logstash","slug":"logstash","link":"/tags/logstash/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"gateway","slug":"gateway","link":"/tags/gateway/"},{"name":"spring cloud","slug":"spring-cloud","link":"/tags/spring-cloud/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"jar","slug":"jar","link":"/tags/jar/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"cmd","slug":"cmd","link":"/tags/cmd/"}],"categories":[{"name":"code","slug":"code","link":"/categories/code/"}]}